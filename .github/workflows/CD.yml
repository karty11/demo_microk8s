name: CD - Deploy to microk8s (CSI + AWS Secrets)

on:
  workflow_dispatch:  # <-- manual trigger only

jobs:
  deploy:
    runs-on: self-hosted
    steps:
     - name: Checkout
       uses: actions/checkout@v4
     - name: Install Helm manually (macOS)
       run: |
         brew install helm
   
     - name: Verify Helm & Kubectl
       run: |
        kubectl version --client
        helm version

     - name: Set up Helm
       uses: azure/setup-helm@v3
       with:
         version: v3.14.0   

     - name: Configure kubectl for MicroK8s
       run: |
        echo "Waiting for MicroK8s to be ready..."
        microk8s status --wait-ready

        echo "Exporting kubeconfig..."
        microk8s config > ~/.kube/config
        chmod 600 ~/.kube/config

        echo "Checking node status..."
        kubectl get nodes -o wide

     - name: Install CSI Secrets Store Driver + AWS Provider
       run: |
        echo "Adding Helm repositories..."
        helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts || true
        helm repo add aws-secrets-manager https://aws.github.io/secrets-store-csi-driver-provider-aws || true
        helm repo update

        echo "Installing Secrets Store CSI Driver..."
        helm upgrade --install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver \
          --namespace kube-system --create-namespace \
          --set enableSecretRotation=true \
          --set rotationPollInterval="1h" \
          --wait --timeout 5m

        echo "Removing old ServiceAccount to avoid Helm ownership conflict..."
        kubectl delete sa secrets-store-csi-driver -n kube-system --ignore-not-found=true

        echo "Installing AWS Secrets Manager Provider (manifest)..."
        kubectl apply -f https://raw.githubusercontent.com/aws/secrets-store-csi-driver-provider-aws/main/deployment/aws-provider-installer.yaml
        echo "Waiting for AWS provider pods..."
        kubectl -n kube-system rollout status daemonset/csi-secrets-store-provider-aws --timeout=2m

        echo "Verifying installation..."
        kubectl -n kube-system get pods -l "app=secrets-store-csi-driver" || true
        kubectl -n kube-system get pods -l "app=csi-secrets-store-provider-aws" || true


     - name: Install Stakater Reloader
       run: |
         helm repo add stakater https://stakater.github.io/stakater-charts
         helm repo update
         helm upgrade --install reloader stakater/reloader \
          --namespace kube-system --create-namespace \
          --wait --timeout 5m    
         
     - name: Create provider ServiceAccount & (fallback) AWS creds secret
       run: |
        kubectl apply -f infra/aws-csi/sa-aws-provider.yaml

     - name: secrets
       run: |
        kubectl apply -f infra/mssql/secret.yaml  

      # If running outside EKS, optionally create aws-creds secret (DO NOT store real creds in repo)

      # kubectl apply -f infra/aws-csi/aws-creds-secret-example.yaml
     - name: Deploy MSSQL (dev/test)
       run: |
        kubectl apply -f infra/mssql/mssql-statefulset.yaml
     - name: Apply SecretProviderClass (mount AWS secret bankapp/mysql)
       run: |
         kubectl apply -f infra/aws-csi/secretproviderclass.yaml
     - name: Install ArgoCD (with CRDs)
       run: |
          echo "üîπ Creating argocd namespace (if missing)..."
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

          echo "üîπ Installing ArgoCD components..."
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

          echo "üîπ Waiting for ArgoCD pods to be ready..."
          kubectl wait --for=condition=available deployment/argocd-server -n argocd --timeout=300s
          kubectl wait --for=condition=available deployment/argocd-repo-server -n argocd --timeout=300s

          echo "‚úÖ ArgoCD is ready!"

      # 4Ô∏è‚É£ Deploy the ArgoCD Application
     - name: Deploy Java Backend ArgoCD Application
       run: |
          echo "üîπ Verifying CRDs..."
          kubectl get crd applications.argoproj.io || \
            (echo "‚ùå ArgoCD CRDs not found!" && exit 1)

          echo "üîπ Applying Application manifest..."
          kubectl apply -f infra/argocd/app-java-backend.yaml

          echo "üîπ Verifying ArgoCD Application resource..."
          kubectl get application java-backend -n argocd || true

      # 5Ô∏è‚É£ Wait for ArgoCD Application sync
     - name: Wait for Application Sync
       run: |
          echo "üîπ Waiting for ArgoCD Application sync..."
          for i in {1..15}; do
            STATUS=$(kubectl get application java-backend -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "unknown")
            HEALTH=$(kubectl get application java-backend -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "unknown")
            echo "Sync: $STATUS | Health: $HEALTH"
            if [[ "$STATUS" == "Synced" && "$HEALTH" == "Healthy" ]]; then
              echo "‚úÖ Application is synced and healthy!"
              exit 0
            fi
            echo "‚è≥ Waiting..."
            sleep 20
          done
          echo "‚ùå Application did not reach Synced/Healthy state in time."
          kubectl describe application java-backend -n argocd || true
          exit 1
          
     - name: Show pods
       run: |
         kubectl get pods --all-namespaces -o wide

     - name: Validate AWS secret mount via test pod
       run: |
         kubectl apply -f infra/aws-csi/test-pod.yaml
         kubectl wait --for=condition=Ready pod/aws-secret-test --timeout=60s
         kubectl exec -it aws-secret-test -- ls /mnt/secrets
         kubectl exec -it aws-secret-test -- cat /mnt/secrets/SPRING_DATASOURCE_USERNAME
         kubectl delete pod aws-secret-test     
